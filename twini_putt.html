<!DOCTYPE html>
<html> 
    <head>
        <title>Twini Putt</title> 
        <style type="text/css">
            #canvasp {
                position: relative;
                top: 150px
            }
        </style>
    </head>
    <body>
        <p style="text-align:center" id="canvasp">
            <canvas id="mycanvas" align="center"></canvas> 
        </p>
    </body>
 
    <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 

    <script>
        var programCode = function(processingInstance) {
            with (processingInstance) {

size(600, 600); 


{
angleMode = "radians";
smooth();
frameRate(60);} // setup

{
var ballColor = color(255); // the color of the balls
var ballStroke = color(0, 0, 0); // stroke color of the balls
var ballStrokeWeight = 3; // the stroke weight of the balls
var obstacleStrokeWeight = 3;
var ballSize = 10; // the size of the balls
var ballR = ballSize/2;
var bounciness = -0.8; // how much speed balls retain when bouncing
var holePos = []; // the hole positions for the current level
var numHoles = 0; // the total number of balls that are in a hole
var holeSize = 15; // the size of the holes
var topBarHeight = 30; // the height of the top bar
var strokes = 0;
var golfBalls;
var showHitBoxes = false;} // vars

var levelInd = 1; // indicates which level from the level array should be displayed

{
function p(x, y) {
    return {x: x, y: y};
}; // makes my code shorter

function createLine(x1, y1, x2, y2){
    return {x1: x1, y1: y1, x2: x2, y2: y2};
}; // returns object with an x1, y1, x2, and y2

function distSq(x1, y1, x2, y2) {
    return sq(x2 - x1) + sq(y2 - y1);
}; // a faster way to do circle-circle collisions

function drawLine(line1){
    line(line1.x1, line1.y1, line1.x2, line1.y2);
}; // mostly for debugging

function printLineStats(line){
    println("x1: " + line.x1);
    println("y1: " + line.y1);
    println("x2: " + line.x2);
    println("y2: " + line.y2);
}; // this is solely for debugging

function rotPoint(point, rect1, a){

    var distToRect = dist(point.x, point.y, rect1.position.x + rect1.width/2, rect1.position.y + rect1.height/2);
    var ang = atan2(point.y - (rect1.position.y + rect1.height/2), point.x - (rect1.position.x + rect1.width/2));
    var nx, ny;
    if (a === 0) {
        nx = rect1.position.x + rect1.width/2 + cos(ang + rect1.rotation) * distToRect;
        ny = rect1.position.y + rect1.height/2 + sin(ang + rect1.rotation) * distToRect;
    } else {
        nx = (rect1.position.x + rect1.width/2) + cos(ang - rect1.rotation) * distToRect;
        ny = (rect1.position.y + rect1.height/2) + sin(ang - rect1.rotation) * distToRect; 
    }
    return p(nx, ny);
}; // rotates a point around the center of a rect

function closestPointOnRect(rect, circ, rot) {
    if (rect.rotation === 0 || rot) {
        var nx = constrain(circ.position.x, rect.position.x, rect.position.x + rect.width);
        var ny = constrain(circ.position.y, rect.position.y, rect.position.y + rect.height);
        return p(nx, ny);
    } else {
        var point = {x: circ.position.x, y: circ.position.y};
        var np = rotPoint(point, rect);
        np.r = circ.r;
        np.position = p(np.x, np.y);

        return rotPoint(closestPointOnRect(rect, np, true), rect, 0);
    }  
};

function rectCirc(rect, circ) {
    var point = closestPointOnRect(rect, circ, true);
    var nx = point.x;
    var ny = point.y;
    return distSq(nx, ny, circ.position.x, circ.position.y) < sq(circ.r);
};

function findSign(n) {
    
    if (n === 0){
        return 0;
    }

    return abs(n)/n;
}; // finds sign of n. returns -1, 1, or 0

function lineToCirc(line, circ) {
    var distToCirc = dist(line.x1, line.y1, circ.position.x, circ.position.y);
    var lineCircAngle = atan2(circ.position.y - line.y1, circ.position.x - line.x1);
    var newX = line.x1 + cos(lineCircAngle - line.angle) * distToCirc;
    var newY = line.y1 + sin(lineCircAngle - line.angle) * distToCirc;
    var newLine = createLine(line.x1, line.y1, line.x1 + line.mag, line.y1);
    var constX = constrain(newX, newLine.x1, newLine.x2);
    if (distSq(constX, newLine.y1, newX, newY) < sq(circ.r + line.strokeWeight/2)){
        return true;
    }
    return false;
}; // sees if a line is colliding with a circle

function createRectSide(rect1, side, bulge) {
    var point1;
    var point2;
    //bulge = 0;
    switch (side) {
        case "top":
            point1 = {x: rect1.position.x - bulge, y: rect1.position.y - bulge};
            point2 = {x: rect1.position.x + rect1.width + bulge, y: rect1.position.y - bulge};
            break;
        case "left":
            point1 = {x: rect1.position.x - bulge, y: rect1.position.y - bulge};
            point2 = {x: rect1.position.x - bulge, y: rect1.position.y + rect1.height + bulge};
            break;
        case "right":
            point1 = {x: rect1.position.x + rect1.width + bulge, y: rect1.position.y - bulge};
            point2 = {x: rect1.position.x + rect1.width + bulge, y: rect1.position.y + rect1.height + bulge};
            break;
        case "bottom":
            point1 = {x: rect1.position.x - bulge, y: rect1.position.y + rect1.height + bulge};
            point2 = {x: rect1.position.x + rect1.width + bulge, y: rect1.position.y + rect1.height + bulge};
            break;
    }
    
    var p1 = rect1.rotation === 0 ? point1 : rotPoint(point1, rect1, 0);
    var p2 = rect1.rotation === 0 ? point2 : rotPoint(point2, rect1, 0);
    return createLine(p1.x, p1.y, p2.x, p2.y);
}; // creates a line coresponding to the side of a rotated rectangle

function rotColl(circ, rect1) {
    var point = {x: circ.position.x, y: circ.position.y};
    var np = rotPoint(point, rect1);
    np.r = circ.r;
    np.position = p(np.x, np.y);
    return rectCirc(rect1, np);
}; // circ to rotated rectangle collision detection

function lineAng(line) {
    return atan2(line.y2 - line.y1, line.x2 - line.x1);
};} // some functions

{
var levels = [
{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 500, origin: "right"},
    obstacles: [{x: 100, y: 300, width: 355, height: 20, type: "wall", rotation: radians(100), rectAlign: "center"}, {x: 200, y: 300, width: 355, height: 20, type: "wall", rotation: radians(80), rectAlign: "center"}, {x: 150, y: 130, width: 60, height: 20, type: "wall", rotation: radians(0), rectAlign: "center"}, {x: 400, y: 300, width: 355, height: 20, type: "wall", rotation: radians(100), rectAlign: "center"}, {x: 500, y: 300, width: 355, height: 20, type: "wall", rotation: radians(80), rectAlign: "center"}, {x: 450, y: 130, width: 60, height: 20, type: "wall", rotation: radians(0), rectAlign: "center"},],
    holes: [{x: 150, y: 150}, {x: 450, y: 150}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 100, origin: "right"},
    obstacles: [{x: 50, y: 290, width: 246, height:20, type: "wall", }, {x: 400, y: 290, width: 199, height:20, type: "wall", }, {x: 450, y: 130, width: 60, height: 20, type: "wall", rotation: PI/4, rectAlign: "center"}, ],
    holes: [{x: 150, y: 100}, {x: 450, y: 500}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 500, origin: "right"},
    obstacles: [{x: 1, y: 180, width: 240, height: 280, type: "hill", direc: new PVector(0.5, 0), }, {x: 359, y: 180, width: 240, height: 280, type: "hill", direc: new PVector(-0.5, 0), }, {x: 1, y: 100, width: 296, height:20, type: "wall", }, {x: 303, y: 100, width: 296, height:20, type: "wall", }],
    holes: [{x: 150, y: 150}, {x: 450, y: 150}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 200, origin: "right"},
    obstacles: [{x: 1, y: 1, width: 99, height: 329, type: "water", }, {x: 200, y: 1, width: 96, height: 329, type: "water", }, {x: 1, y: 333, width: 99, height: 10, type: "wall", }, {x: 200, y: 333, width: 96, height: 10, type: "wall", }, {x: 304, y: 1, width: 395, height: 100, type: "water", }],
    holes: [{x: 150, y: 100}, {x: 450, y: 400}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 500, origin: "right"},
    obstacles: [{x1: 200, y1: 350, x2: 400, y2: 350, strokeWeight: 50, type: "water", shape: "line"}, {x1: -100, y1: 250, x2: 150, y2: 250, strokeWeight: 50, type: "sand", shape: "line"}, {x1: 400, y1: -500, x2: 400, y2: 250, strokeWeight: 50, type: "water", shape: "line"}, {x1: 500, y1: 100, x2: 500, y2: 250, strokeWeight: 50, type: "water", shape: "line"}, {x: 195, y: 53, width: 80, height: 230, type: "hill", direc: new PVector(0, -0.5), }, {x: 1, y: 200, width: 190, height: 10, type: "wall", }, {x: 570, y: -10, width: 99, height: 100, type: "water", }],
    holes: [{x: 150, y: 150}, {x: 550, y: 150}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 500, origin: "right"},
    obstacles: [{x: 0, y: 150, r: 60, type: "wall", shape: "circ"}, {x: 600, y: 150, r: 60, type: "wall", shape: "circ"}, {x: 300, y: 150, r: 60, type: "wall", shape: "circ"}, {x: 150, y: 350, r: 60, type: "wall", shape: "circ"}, {x: 450, y: 350, r: 60, type: "wall", shape: "circ"}, {x1: -500, y1: 100, x2: 350, y2: 850, strokeWeight: 200, type: "water", shape: "line"}, {x1: 1100, y1: 100, x2: 250, y2: 850, strokeWeight: 200, type: "water", shape: "line"}],
    holes: [{x: 150, y: 150}, {x: 450, y: 150}]
},{
    strt1: {x: 150, y: 400, origin: "left"},
    strt2: {x: 450, y: 400, origin: "right"},
    obstacles: [{x1: -100, y1: 400, x2: 350, y2: 850, strokeWeight: 200, type: "wall", shape: "line"}, {x1: 700, y1: 400, x2: 250, y2: 850, strokeWeight: 200, type: "wall", shape: "line"}, {x1: 100, y1: 400, x2: 350, y2: 250, strokeWeight: 20, type: "wall", shape: "line"}],
    holes: [{x: 150, y: 100}, {x: 450, y: 100}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 200, origin: "right"},
    obstacles: [{width: 60, height: 10, r: 50, type: "move", shape: "rect", targets: [p(80, 20), p(180, 70), p(180, 170), p(80, 170)], speed: 1, }],
    holes: [{x: 150, y: 100}, {x: 450, y: 400}]
},{
    strt1: {x: 150, y: 500, origin: "left"},
    strt2: {x: 450, y: 500, origin: "right"},
    obstacles: [{x: 200, y: 100, width: 50, height:50, type: "wall", }, {x: 200, y: 300, width: 10, height: 400, type: "wall", }],
    holes: [{x: -285, y: 150}, {x: -450, y: 150}]
}
]; /* contains the level data for all of the levels*/} // da leeveeels

{
function calcSlope(line) {
    return (line.y2 - line.y1) / (line.x2 - line.x1);
}; // returns the slope of a line

function calcIntercept(line, slope) {
    var x = line.x1;
    var y = line.y1;
    return y - slope * x;
}; // returns intercept (b in mx + b = y)

function isPointOnLine(line, point) {
    if(point.x >= min(line.x1, line.x2) && point.x <= max(line.x1, line.x2) && point.y >= min(line.y1, line.y2) && point.y <= max(line.y1, line.y2)){
        return true;
    }
    return false;
}; // finds if a point is on a line

function prepLine(line) {
    if(line.x1 === line.x2){
        return {x: line.x1, vertical: true, x1: line.x1,  y1: line.y1,  x2: line.x2,  y2: line.y2};
    }
    var m = calcSlope(line);
    return {m: m, b: calcIntercept(line, m), x1: line.x1,  y1: line.y1,  x2: line.x2,  y2: line.y2};
}; // takes a line object and injects slope, intercept, and a vertical-ness boolean

function findIntersection(line1, line2) {
    line1 = prepLine(line1);
    line2 = prepLine(line2);
  if (line1.vertical && line2.vertical) {
    // Both lines are vertical, no intersection
    return {inter: false};
  } else if (line1.vertical) {
    // Line 1 is vertical, calculate intersection with Line 2
    var x = line1.x;
    var y = line2.m * x + line2.b;
    return {x: x, y: y, inter: isPointOnLine(line1, {x: x, y: y}, line1.m) && isPointOnLine(line2, {x: x, y: y}, line2.m)};
  } else if (line2.vertical) {
    // Line 2 is vertical, calculate intersection with Line 1
    var x = line2.x;
    var y = line1.m * x + line1.b;
    return {x: x, y: y, inter: isPointOnLine(line1, {x: x, y: y}, line1.m) && isPointOnLine(line2, {x: x, y: y}, line2.m)};
  } else {
    // Both lines are non-vertical, calculate intersection
    var x = (line2.b - line1.b) / (line1.m - line2.m);
    var y = line1.m * x + line1.b;
    return {x: x, y: y, inter: isPointOnLine(line1, {x: x, y: y}, line1.m) && isPointOnLine(line2, {x: x, y: y}, line2.m)};
  }
}; /* finds the intersection point of two lines, assuming the lines go infinitely in both directions */ } // line intersection shtuff

{
var Particle = function(position, type) {
    this.acceleration = new PVector(0, 0);
    this.position = position.get();
    this.timeToLive = 100.0;
    this.type = type;
    switch (this.type) {
        case "splash":
            this.velocity = new PVector(0, 0);
            break;
        case "grass":
            this.velocity = new PVector(random(-0.5, 0.5), random(-0.5, 0.5));
            break;
    }
};

Particle.prototype.display = function() {
    switch(this.type) {
        case "splash":
            noFill();
            stroke(255, (this.timeToLive - 50) * 2);
            strokeWeight(1);
            ellipse(this.position.x, this.position.y, (100 - this.timeToLive) * 2, (100 - this.timeToLive) * 2);
            break;
        case "grass":
            rectMode(CENTER);
            fill(0, 100, 0, this.timeToLive/1.5);
            noStroke();
            pushMatrix();
            translate(this.position.x, this.position.y);
            var theta = map(this.position.x, 0, width, 0, TWO_PI * 2);
            rotate(theta);
            rect(0, 0, 8, 8);
            popMatrix();
            rectMode(CORNER);
    }
};

Particle.prototype.update = function() {
    this.position.add(this.velocity);
    this.timeToLive --;
};

Particle.prototype.run = function() {
    this.update();
    this.display();
};

var ParticleSystem = function(x, y, type, delay, numParticles, ballNum) {
    this.position = new PVector(x, y);
    this.type = type;
    this.particles = [];
    this.delay = delay;
    this.curDelay = 0;
    this.time = 0;
    this.numParticles = numParticles;
    this.golfBall = ballNum || 0;
    this.numParticlesMade = 0;
};

ParticleSystem.prototype.addParticle = function() {
    this.particles.push(new Particle(this.position, this.type));
};

ParticleSystem.prototype.run = function() {

    switch (this.type) {   
        case "grass":
            var b = golfBalls.balls[this.golfBall];
            if (this.curDelay >= this.delay && this.numParticlesMade < this.numParticles && !b.relaunch && !b.hitHole) {
                this.addParticle();
                this.numParticlesMade ++;
            }

            this.position.set(b.position.x, b.position.y);
            var vel = b.velocity.get();
            this.delay = 25 - vel.mag()* 3;
            break;
        default:

            if (this.curDelay >= this.delay && this.numParticlesMade < this.numParticles) {
                this.addParticle();
                this.numParticlesMade ++;
            }
    }
    
    if (this.curDelay > this.delay) {
        this.curDelay = 0;
    }
    for (var i = this.particles.length - 1; i >= 0; i--) {
        this.particles[i].run();
        if (this.particles[i].timeToLive <= 0){
            this.particles.splice(i, 1);
        }
    }

    this.curDelay ++;  
}; 

var ParticleSystems = function() {
    this.particleSystems = [];
};

ParticleSystems.prototype.add = function(x, y, type, delay, numParticles, ballNum) {
    this.particleSystems.push(new ParticleSystem(x, y, type, delay, numParticles, ballNum));
};

ParticleSystems.prototype.run = function() {
    for (var i = this.particleSystems.length - 1; i >= 0; i--) {
        this.particleSystems[i].run();
        if (this.particleSystems[i].particles.length <= 0 && this.particleSystems[i].numParticlesMade > this.particleSystems[i].numParticles) {
            this.particleSystems.splice(i, 1);
        }
    }
};

var gameParticles = new ParticleSystems();} // particles =P

{
function Obstacle(config) {

    this.shape = config.shape === undefined ? "rect" : config.shape;
    this.type = config.type;

    if (this.shape === "rect") {
        this.createSides = function () {
            this.sides = [createRectSide(this, "top", ballR), createRectSide(this, "bottom", ballR), createRectSide(this, "left", ballR), createRectSide(this, "right", ballR)];
        };
        this.position = this.type === "move" ? new PVector(config.targets[0].x, config.targets[0].y) : new PVector(config.x, config.y);
        this.width = config.width;
        this.height = config.height;
        this.rotation = config.rotation || 0;
        this.createSides();
    } else if (this.shape === "line") {
        this.x1 = config.x1;
        this.x2 = config.x2;
        this.y1 = config.y1;
        this.y2 = config.y2;
        this.strokeWeight = config.strokeWeight;
        this.mag = dist(this.x1, this.y1, this.x2, this.y2);
        this.angle = lineAng(this);
    } else if (this.shape === "circ") {
        this.position = this.type === "move" ? new PVector(config.targets[0].x, config.targets[0].y) : new PVector(config.x, config.y);
        this.r = config.r;
    }

    if (this.type === "move"){ // if its a moving block
        this.targets = config.targets; // where the moving blocks will go to
        this.curTarget = 1; // the target that it should be moving towards if its a moving block
        this.angle = atan2(this.targets[1].y - this.targets[0].y, this.targets[1].x - this.targets[0].x);
        this.speed = config.speed; // speed for moving blocks
    }

    if (this.type === "hill" ) {
        if (this.width % 40 !== 0) {
            this.width += this.width % 40;          
        }
        if (this.height % 40 !== 0) {
            this.height += this.height % 40;
        }
        this.direc = config.direc; // this is the direction of the hill
    }
    // the colors
    switch (this.type) {
    case "wall":
        this.color1 = color(230, 192, 41);
        this.color2 = color(153, 130, 55);
        break;
    case "water":
        this.color1 = color(70, 70, 255);
        this.color2 = color(100, 100, 255);
        break;
    case "sand":
        this.color1 = color(227, 211, 132);
        this.color2 = color(181, 159, 79);
        break;
    case "move":
        this.color1 = color(150);
        this.color2 = color(100);
        break;
    }
};

Obstacle.prototype.draw = function(col, offSet) {
    var pos;
    if (this.shape === "rect" || this.shape === "circ") {
        pos = this.position.get();
    }
    if (col === undefined) {
        switch(this.type){
        case "wall":
            fill(230, 192, 41);
            stroke(153, 130, 55);
            strokeWeight(obstacleStrokeWeight);
            if(showHitBoxes) {
                for(var i in this.sides) {
                    drawLine(this.sides[i]);
                }  
            }
           
            if (this.shape === "rect") {
                pushMatrix();
                translate(pos.x + this.width/2, pos.y + this.height/2);
                rotate(this.rotation);
                rect(-this.width/2 + obstacleStrokeWeight/2, -this.height/2 + obstacleStrokeWeight/2, this.width - obstacleStrokeWeight, this.height - obstacleStrokeWeight);
                popMatrix();
            } else if (this.shape === "circ") {
                ellipse(pos.x, pos.y, this.r * 2 - obstacleStrokeWeight/2, this.r * 2 - obstacleStrokeWeight/2);
            } else if (this.shape === "line") {
                stroke(153, 130, 55);
                strokeWeight(this.strokeWeight);
                drawLine(this);
                stroke(230, 192, 41);
                strokeWeight(this.strokeWeight - obstacleStrokeWeight*2);
                drawLine(this);
            }
            break;
        case "hill":
                       
            noFill();
            stroke(42, 164, 0);
            strokeWeight(obstacleStrokeWeight);
            rect(pos.x, pos.y, this.width, this.height, 2);
            strokeJoin(ROUND);
            if(this.direc.x === 0 && this.direc.y !== 0){
                var s = findSign(this.direc.y);
                for (var i = 0; i <= this.width/40 - 1; i ++) {
                    beginShape();
                        vertex(this.position.x + i * 40 + 12, (this.position.y + this.height/2) - (this.height/2 * s) + 6 * s);
                        vertex(this.position.x + i * 40 + 20, (this.position.y + this.height/2) + (this.height/2 * s) - 6 * s);
                        vertex(this.position.x + i * 40 + 28, (this.position.y + this.height/2) - (this.height/2 * s) + 6 * s);
                    endShape();
                }
                
            } else if(this.direc.y === 0 && this.direc.x !== 0){
                var s = findSign(this.direc.x);
                for (var i = 0; i <= this.height/40 - 1; i ++) {
                    beginShape();
                        vertex((this.position.x + this.width/2) - (this.width/2 * s) + 6 * s, this.position.y + i * 40 + 12);
                        vertex((this.position.x + this.width/2) + (this.width/2 * s) - 6 * s, this.position.y + i * 40 + 20);
                        vertex((this.position.x + this.width/2) - (this.width/2 * s) + 6 * s, this.position.y + i * 40 + 34);
                    endShape();
                }
            }
            break;
        case "move":
            fill(150);
            stroke(100);
            strokeWeight(obstacleStrokeWeight);
            if (this.shape === "rect") {
                rect(pos.x + obstacleStrokeWeight/2, pos.y + obstacleStrokeWeight/2, this.width - obstacleStrokeWeight, this.height - obstacleStrokeWeight, 4);
            } else if (this.shape === "circ") {
                ellipse(pos.x, pos.y, this.r * 2 - obstacleStrokeWeight, this.r * 2 - obstacleStrokeWeight);
            }
            break;
        case "water":
            fill(70, 70, 255);
            stroke(100, 100, 255);
            strokeWeight(3);
            if (this.shape === "rect") {
                rect(pos.x, pos.y, this.width, this.height, 2);    
            } else if (this.shape === "line") {
                stroke(100, 100, 255);
                strokeWeight(this.strokeWeight + 6);
                drawLine(this);
                stroke(70, 70, 255);
                strokeWeight(this.strokeWeight);
                drawLine(this);
            } else if (this.shape === "circ") {
                ellipse(pos.x, pos.y, this.r * 2, this.r * 2);
            }
            break;
        case "sand":
            fill(227, 211, 132);
            stroke(181, 159, 79);
            strokeWeight(3);
            if (this.shape === "rect") {
                rect(pos.x, pos.y, this.width, this.height, 2);    
            } else if (this.shape === "line") {
                stroke(181, 159, 79);
                strokeWeight(this.strokeWeight + 6);
                drawLine(this);
                stroke(227, 211, 132);
                strokeWeight(this.strokeWeight);
                drawLine(this);
            } else if (this.shape === "circ") {
                ellipse(pos.x, pos.y, this.r * 2, this.r * 2);
            }
            break;
        default:
            break;
        }
    } else {
        switch (this.shape) {
        case "rect":
            var w = this.width;
            var h = this.height;
            pushMatrix();
            translate(pos.x + w/2, pos.y + h/2);
            rotate(this.rotation);
            noStroke();
            fill(col);
            rect(-w/2 + offSet/2, -h/2 + offSet/2, w - offSet, h - offSet);
            popMatrix();
            break;
        case "line":
            stroke(col);
            strokeWeight(this.strokeWeight - offSet);
            drawLine(this);
            break;
        case "circ":
            noStroke();
            fill(col);
            ellipse(pos.x, pos.y, this.r * 2 - offSet, this.r * 2 - offSet);
            break;
        default:
            throw {mesage: "you did something wrong and its all your fault"};
        }
    }
};

Obstacle.prototype.update = function() {
    if (this.type === "move") {
        if (distSq(this.position.x, this.position.y, this.targets[this.curTarget].x, this.targets[this.curTarget].y) < sq(this.speed)) {
            
            this.position.x = this.targets[this.curTarget].x;
            this.position.y = this.targets[this.curTarget].y;

            this.curTarget ++;
            if (this.curTarget >= this.targets.length) {
                this.curTarget = 0;
                this.angle = atan2(this.targets[this.curTarget].y - this.targets[this.targets.length - 1].y, this.targets[this.curTarget].x - this.targets[this.targets.length - 1].x);
            } else {
                this.angle = atan2(this.targets[this.curTarget].y - this.targets[this.curTarget - 1].y, this.targets[this.curTarget].x - this.targets[this.curTarget - 1].x);
            }
        } else {
            this.position.x += cos(this.angle) * this.speed;
            this.position.y += sin(this.angle) * this.speed;
        }
        if (this.shape === "rect") {
            this.createSides();
        }
        
    }
};

Obstacle.prototype.run = function() {
    this.update();
    this.draw(this.color2, 0);
    this.draw(this.color1, 6);
    //this.draw();
};

var ObstacleSystem = function(){
    this.obstacles = [];
};


ObstacleSystem.prototype.run = function() {
    for (var i in this.obstacles){
        this.obstacles[i].update();
        this.obstacles[i].draw(this.obstacles[i].color2, 0);
    }
    for (var i in this.obstacles){
        this.obstacles[i].draw(this.obstacles[i].color1, 6);
    }
};

var obstacles = new ObstacleSystem(); /* obstacles in the current level */} // obstacles

{
var GolfBall = function(config){
    this.position = new PVector(config.x, config.y);
    this.startPosition = this.position.get();
    this.velocity = new PVector(0, 0, 0);
    this.acceleration = new PVector(0, 0, 0);
    this.mass = 3;
    this.size = config.size;
    this.r = this.size/2;
    this.originSide = config.originSide;
    this.relaunch = false;
    this.show = true;
    this.inHole = false; // when to go to the next level
    this.hitHole = false; // when to start the animation
    this.canStop = true;
    this.inWater = false;
    this.waterResetDelay = 30;
    this.pastX = this.position.x;
    this.pastY = this.position.y;
};

GolfBall.prototype.draw = function() {
    stroke(ballStroke);
    strokeWeight(ballStrokeWeight);
    fill(ballColor);
    var pos = this.position;
    ellipse(pos.x, pos.y, this.size - ballStrokeWeight/2, this.size - ballStrokeWeight/2);
};

GolfBall.prototype.applyForce = function(force){
    var f = PVector.div(force, this.mass);
    this.acceleration.add(f);
};

GolfBall.prototype.isColliding = function(obstacle){
    
    var bPos = this.position;
    var oPos = obstacle.position;
    var o = obstacle;
    var r = this.r;
    if (o.shape === "rect") {
        return o.rotation === 0 ? rectCirc(o, this) : rotColl(this, o);
    } else if (o.shape === "line") {
        return lineToCirc(o, this);
    } else if (o.shape === "circ") {
        return distSq(bPos.x, bPos.y, oPos.x, oPos.y) < sq(r + o.r);
    }
    return false;
};

GolfBall.prototype.lineBounce = function(o) {

    // find variables necessary to find the closest spot on the line to the ball
    var lineMag = o.mag;
    var distToCirc = dist(o.x1, o.y1, this.position.x, this.position.y);
    var lineAngle = o.angle;
    var lineCircAngle = atan2(this.position.y - o.y1, this.position.x - o.x1);

    // create a new x position for the ball, rotated back along the lines angle
    var newX = o.x1 + cos(lineCircAngle - lineAngle) * distToCirc;

    // find the closest spot on the rotated line to the new x
    var constX = constrain(newX, o.x1, o.x1 + lineMag);

    // find the distance from that point to the x1 of the line
    var constD = constX - o.x1;

    // calculate the closest position on the unmodified line
    newX = o.x1 + cos(lineAngle) * constD;
    var newY = o.y1 + sin(lineAngle) * constD;

    // create the circle for the ball to bounce off of
    var ball = {position: new PVector(newX, newY), r: o.strokeWeight/2, type: o.type};

    // bounce the ball of of the circle
    this.circBounce(ball);
};

GolfBall.prototype.circBounce = function(o) {
    // calculate the minimum translation distance to move the balls apart
    var delta = PVector.sub(this.position, o.position);
    var d = delta.mag();
    var mtd = PVector.mult(delta, ((this.r + o.r)-d)/d);

    // calculate the masses. obstacle mass is infinity so that it dosent move
    var im1 = 1 / this.size; 
    var im2 = 1 / Infinity;

    // move the ball out of the obstacle
    this.position.add(PVector.mult(mtd, im1 / (im1 + im2)));

    // find the velocity of the impact
    var v;
    if (o.type === "wall") {
        v = this.velocity;
    } else if (o.type === "move") {
        v = PVector.sub(this.velocity, new PVector(cos(o.angle) * o.speed, sin(o.angle) * o.speed));
    }

    // calculate the direction of impact
    mtd.normalize();
    var vn = PVector.dot(v, mtd);

    // the balls are already moving away from eachother
    if (vn > 0) {return;}

    // calculate the impulse
    var i = (-(1 - bounciness) * vn) / (im1 + im2);
    var impulse = PVector.mult(mtd, i);

    // add the velocities
    this.velocity.add(PVector.mult(impulse, im1));
};

GolfBall.prototype.move = function() {

    // move the golf ball
    this.velocity.add(this.acceleration);
    this.velocity.mult(0.985);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
}; 

GolfBall.prototype.edgeBounce = function() {

    var r = this.r; // for easier access

    // bounce off of the edges of the screen
    if(this.position.x - r < 0){
        this.position.x = r;
        this.velocity.x *= bounciness;
    } else if(this.position.x + r > width){
        this.position.x = width - r;
        this.velocity.x *= bounciness;
    }  else if(this.position.y - r < topBarHeight){
        this.position.y = r + topBarHeight;
        this.velocity.y *= bounciness;
    }  else if(this.position.y + r > height){
        this.position.y = height - r;
        this.velocity.y *= bounciness;
    } 

    // bounce off of the middle line
    switch(this.originSide){
        case "left":
            if(this.position.x + r + 2.5 > width/2){
                this.position.x = width/2 - r - 2.5;
                this.velocity.x *= bounciness;
            }
            break;
        case "right":
            if(this.position.x - r - 2.5 < width/2){
                this.position.x = width/2 + r + 2.5;
                this.velocity.x *= bounciness;
            }
            break;
    }
};

GolfBall.prototype.createMovmentLine = function(o) {

    noStroke();
    fill(255, 0, 0);
    
    stroke(255, 0, 0);
    strokeWeight(1);
    var movementVec;
    movementVec = new PVector((this.position.x - this.pastX), (this.position.y - this.pastY));
    if (o.type === "move") {
        movementVec.add(new PVector(cos(o.angle) * o.speed, sin(o.angle) * o.speed));
    }
    // prevent the movement vector getting really small at low velocities
    movementVec.normalize();
    var normMoveVec = movementVec.get();
    movementVec.mult(width + height);

    // create the movement line from the movment vector
    var movementLine = {x1: this.position.x + normMoveVec.x * this.r, y1: this.position.y + normMoveVec.y * this.r, x2: this.position.x - movementVec.x, y2: this.position.y - movementVec.y};
   
    return movementLine;
};

GolfBall.prototype.findCollSide = function(sides, movementLine) {
    var intersect;
    var smallestDist = Infinity; // keeps track of the shortest distance from intersection to line
    var smallestDistPos = {}; // position of closest intersection
    var smallestDistInd = -1; // line that is being intersected

    // check intersections for all sides of the rect, find the intersection point closest to the ball
    for (var i in sides) {
        intersect = findIntersection(sides[i], movementLine); // find the itersection between the movement line ans
        if (intersect.inter) {
            var d = distSq(this.position.x, this.position.y, intersect.x, intersect.y);
            if (d < smallestDist) {
                smallestDist = d;
                smallestDistPos = {x: intersect.x, y: intersect.y};
                smallestDistInd = i;
            }
        }
    } 

    // no intersection, return false
    if (smallestDistInd < 0) {
        return false;
    }

    return {ind: smallestDistInd, pos: smallestDistPos};
}

GolfBall.prototype.noRotRectBounce = function(o) {

    /* setup */
    var pos = o.position;
    var movementLine = this.createMovmentLine(o);
    stroke(0);
    strokeWeight(5);
    // define the angles to bounce off at in an array
    var bounceAngles = [p(1, bounciness), p(1, bounciness), p(bounciness, 1), p(bounciness, 1)];
    // put all of the sides in an array
    var sides = o.sides;

    /* actually bounce the ball */
    var s = this.findCollSide(sides, movementLine);

    // go to the intersection point
    this.position.x = s.pos.x;
    this.position.y = s.pos.y;

    // change the velocity according to the bounce
    this.velocity.x *= bounceAngles[s.ind].x;
    this.velocity.y *= bounceAngles[s.ind].y;

    if (o.type === "move") {
        this.relaunch = false;
    }
};

GolfBall.prototype.rotRectBounce = function(o) {

    /* setup */
    var pos = o.position;
    var movementVec;
    var r = this.r;

    // this will be used to dreate the movment line
    var movementLine = this.createMovmentLine(o);

    // put all of the sides in an array
    var sides = o.sides;

    // find the intersection point between the lines and the velocity vector
    var s = this.findCollSide(sides, movementLine);

    this.position.set(s.pos.x, s.pos.y);

    var side = sides[s.ind];
    var ang1 = lineAng(side);
    var ang2 = lineAng(movementLine);
    var theta = ang2 - ang1;
    ang1 += PI;
    ang1 -= theta;
    var mag = this.velocity.mag() * -bounciness;
    this.velocity.x = cos(ang1) * mag;
    this.velocity.y = sin(ang1) * mag;
};

GolfBall.prototype.obstacleBounce = function() {

    // loop through all of the obstacles
    for(var i in obstacles.obstacles){ 

        var col = this.isColliding(obstacles.obstacles[i]); // is the ball coliding with the obstacle?
        var o = obstacles.obstacles[i]; // to easily access properties of the obstacle
        var pos = o.position; // to easily access the position of the obstacle
        // if its colliding

        if (col) {
            if (o.type === "wall" || o.type === "move") {

                if (o.shape === "rect") {
                    if (o.rotation === 0) {
                        this.noRotRectBounce(o);
                    } else {
                        this.rotRectBounce(o);
                    }
                } else if (o.shape === "circ") {

                    // bounce off of a circle wall
                    this.circBounce(o);
                } else if (o.shape === "line") {

                    // bounce off of a line wall
                    this.lineBounce(o);
                }
                
            } else if (o.type === "hill") {
                this.applyForce(o.direc);
                this.canStop = false; // so that it doesn't go into a hill and then stop
            } else if (o.type === "water") {
                this.inWater = true;
            } else if (o.type === "sand") {
                this.velocity.mult(0.6);
            }
        }
    }
};

GolfBall.prototype.update = function() {
    this.pastX = this.position.x;
    this.pastY = this.position.y;

    this.move();

    var r = this.r;

    if(this.canStop && distSq(0, 0, this.velocity.x, this.velocity.y) <= sq(0.3)){ 
        this.velocity.set(0, 0, 0);
        this.relaunch = true;
    } else {
        this.relaunch = false;
    } // stop the ball if its going slow enough
    
    for(var i = 0; i < 2; i++){
        var d = distSq(this.position.x, this.position.y, holePos[i].x, holePos[i].y);
        if(d <= sq(this.size/2 + holeSize/2)){
            var ogVelocity = this.velocity.mag();
            if (d <= sq(holeSize/2 - r) && ogVelocity < 6) {
                this.relaunch = false;
                this.show = false;
                this.hitHole = true;
            } else {
                this.applyForce(new PVector((holePos[i].x - this.position.x)/14, (holePos[i].y - this.position.y)/14));
                this.velocity.limit(ogVelocity);
            }            
        }
    } // check if the ball is in a hole, and apply gravitational forces twoards the hole if the ball is close enough

    this.edgeBounce(); // bounce off of the edges of the screen and keep the ball on its side
    
    this.canStop = true; // will be set to false later if needed

    this.obstacleBounce();
};

var BallSystem = function(){
    this.balls = [];
}; // handles all of the golf balls

BallSystem.prototype.run = function(){
    for (var i = this.balls.length - 1; i >= 0; i--) {
        if(this.balls[i].show){
            this.balls[i].update();
            this.balls[i].draw();
            if (this.balls[i].relaunch) { // draw the doted aim thing
                noStroke();
                fill(0, 100);
                if(mouseX <= width/2){
                    for(var j = 10; j <= 100; j += 10){
                        ellipse(lerp(this.balls[i].position.x, mouseX - (this.balls[0].position.x - this.balls[i].position.x), j/100), lerp(this.balls[i].position.y, mouseY  - (this.balls[0].position.y - this.balls[i].position.y), j/100), (100 - j)/10, (100 - j)/10);
                    }
                } else if(mouseX > 300){
                    for(var j = 10; j <= 100; j += 10){
                        ellipse(lerp(this.balls[i].position.x, mouseX - (this.balls[1].position.x - this.balls[i].position.x), j/100), lerp(this.balls[i].position.y, mouseY  - (this.balls[1].position.y - this.balls[i].position.y), j/100), (100 - j)/10, (100 - j)/10);
                    }
                }
            }
        } else if (this.balls[i].hitHole){
            this.balls[i].size -= 0.1;
            if (this.balls[i].size <= 0 && !this.balls[i].inHole) {
                numHoles ++;
                this.balls[i].inHole = true;
            } else {
                this.balls[i].draw();    
            }
            
        }
        if (this.balls[i].inWater) {
            if (this.balls[i].show) {
                var v = this.balls[i].velocity.get();
                v.mult(2);
                gameParticles.add(this.balls[i].position.x + v.x, this.balls[i].position.y + v.y, "splash", 10, 3);
            }
            this.balls[i].show = false;
            this.balls[i].waterResetDelay --;
            if (this.balls[i].waterResetDelay <= 0) {
                this.balls[i].waterResetDelay = 30;
                this.balls[i].show = true;
                this.balls[i].inWater = false;
                this.balls[i].position.set(this.balls[i].startPosition);
                this.balls[i].velocity.mult(0);
            }
            
        }
             
    }
};

BallSystem.prototype.launch = function(){ // launch the balls

    var strokesIncreased = false; // prevents the strokes being increased by two
    
    for (var i = this.balls.length - 1; i >= 0; i--) {
        if(this.balls[i].relaunch){ // only launch if the balls are allowed to

            var distance; // distance between mouse and the golf ball, but in a PVector

            if(mouseX <= 300){
                distance = new PVector(mouseX - (this.balls[0].position.x - this.balls[i].position.x) - this.balls[i].position.x, mouseY  - (this.balls[0].position.y - this.balls[i].position.y) - this.balls[i].position.y);
            } else if (mouseX > 300){
                distance = new PVector(mouseX - (this.balls[1].position.x - this.balls[i].position.x) - this.balls[i].position.x, mouseY  - (this.balls[1].position.y - this.balls[i].position.y) - this.balls[i].position.y);
            }

            distance.div(-8); // negative so the balls go away from the mouse
            this.balls[i].applyForce(distance); // apply the force of the launch
            this.balls[i].relaunch = false; // after you launch, set the relaunch to false so it cant launch again until the ball stops

            if (!strokesIncreased) {
                strokes ++; // increase the strokes variable
                strokesIncreased = true; // prevents the strokes being increased by two
            }
        }
    }
};

var golfBalls = new BallSystem(); /* balls in the current level*/} // the golf balls

{
var fillLevel =  function(){ // takes the info from the level array, and then puts it into the global variables for the current level
    
    // clear the arrays
    golfBalls.balls = [];
    obstacles.obstacles = [];
    gameParticles.particleSystems = [];

    // add the golf balls for the current level
    golfBalls.balls.push(new GolfBall({
        x: levels[levelInd].strt1.x,
        y: levels[levelInd].strt1.y,
        size: ballSize,
        originSide: levels[levelInd].strt1.origin,
    }));
    gameParticles.add(levels[levelInd].strt1.x, levels[levelInd].strt1.y, "grass", 5, Infinity, 0);

    golfBalls.balls.push(new GolfBall({
        x: levels[levelInd].strt2.x,
        y: levels[levelInd].strt2.y,
        size: ballSize,
        originSide: levels[levelInd].strt2.origin,
    }));

    gameParticles.add(levels[levelInd].strt2.x, levels[levelInd].strt2.y, "grass", 5, Infinity, 1);

    // add the obstacles for the current level
    for(var i = 0; i < levels[levelInd].obstacles.length; i++){
        var curObs = levels[levelInd].obstacles[i];
        var x = curObs.x,
            y = curObs.y;
        if (curObs.rectAlign === "center") {
            x -= curObs.width/2;
            y -= curObs.height/2;
        }

        obstacles.obstacles.push(new Obstacle({
            x: x,
            y: y,
            width: curObs.width,
            height: curObs.height,
            type: curObs.type,
            direc: curObs.direc,
            targets: curObs.targets,
            speed: curObs.speed,
            x1: curObs.x1,
            x2: curObs.x2,
            y1: curObs.y1,
            y2: curObs.y2,
            strokeWeight: curObs.strokeWeight,
            shape: curObs.shape,
            r: curObs.r,
            rotation: curObs.rotation,
        }));
    }

    holePos = levels[levelInd].holes; // hole positions for the current level
    numHoles = 0; // the number of holes made
    
    strokes = 0; // the number of strokes taken
};

fillLevel();
} // set up the level

{
var play = function(){

    background(92, 204, 12);

    // the holes
    fill(0);
    noStroke();
    for(var i in holePos){
        ellipse(holePos[i].x, holePos[i].y, 15, 15);
    }
    
    // the obstacles
    obstacles.run();
    
    // that line in the middle
    stroke(0);
    strokeWeight(5);
    line(width/2, -10, width/2, height + 10);

    

    // the top bar
    noStroke();
    fill(0, 135, 0);
    rect(-10, -10, width + 20, topBarHeight + 10);
    fill(255);
    textSize(20);
    textAlign(RIGHT, TOP);
    if (strokes === 1) {
        text(strokes + " stroke" , width - 5, 3);
    } else {
        text(strokes + " strokes" , width - 5, 3);
    }

    textAlign(CENTER);
    
    // run everything else  
    golfBalls.run();
    gameParticles.run();

    // go to the next level if necessary
    if(numHoles >= 2){
        levelInd ++;
        fillLevel();
    }
};
} // scenes. actuallllly, its scene. whelp

{
var draw = function() {
    play();
};
} // draw shumpkin

{
mouseReleased = function(){
    golfBalls.launch();
};
} // you've got tuh listen to the mouse



            }

        };
        var canvas = document.querySelector("#mycanvas"); 
        var processingInstance = new Processing(canvas, programCode); 

    </script>
</html> 